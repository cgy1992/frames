* Let's make an extremely tentative plan for how the code should look

Frames::Config config;
config->SetBlah(things);

Frames::Environment environment(config);

environment->Render();


// need some kind of ref pointer if we ever want Detach to work as intended
// but we won't use these internally

FramePtr frame = environment.CreateFrame(environment.GetRoot());
frame->SetPoint(Frame::AXIS_X, "blah, etc")

// how do we deal with events?
// right now we have single handles
// should we have multihandles?
// should we do something like qt's signals/slots?

frame.Event_Axis(etc)

so, hmm, things we need
* We need to be able to tell if an event is hooked or not, because there are many cases where an event is expensive to process if it turns out we don't care
* We need an efficient way to queue events
* Events mostly won't have a parameter, but some might
* Priorities? Do we care?

* Each event can, I think, only trigger once per cycle . . . and in the case where it can trigger more than once, maybe that's okay, we can just ignore the later triggers?

mousein/mouseout - can only happen once
move/size/layer/strata/visible - can only happen once
key/mouseclick - can only happen once per cycle
yeah that might be good


so, the lifetime of an event . . .

* user does something that *may* cause an event
  * event triggered
    * if we don't have any handlers, just give up
    * store payload internally
    * add self to a call list in some manner that does not involve allocation - class and fptr only? Does that work? I think it should
  * once we know we're safe, flush all events until we're done with events
  * tada

slow things, like move/size, get delayed until we're about to render - we solidify the render tree, fire all events, repeat, until the render tree stays solid

the signal itself contains a vector of boost functions, or something
maybe flags for language hooks?
  